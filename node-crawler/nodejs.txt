知乎注册知乎登录提问知乎搜索搜索首页话题发现 消息用户赞同和感谢查看全部 »x内容用户话题时间不限一天内一周内三个月内使用nodejs开发的网站有哪些？9赞同9反对，不会显示你的姓名小爝前端开发话题优秀回答者日记：http://tuer.me 圈子：http://t.cn/RiZQL4v已经上线1年多的一个日记本网站兔耳日记 | 首页 完全使用nodejs开发的后台。但是其他一些已经在线上的站点还有哪些？ 我知道的还有cnodejs的社区也是nodejs编写的，还有雪球网貌似也是，还有阿里的数据产品团队也在使用nodejs。渣康、Qbian 等人赞同我自己先来，已经上线1年多的一个日记本网站<a href="//link.zhihu.com/?target=http%3A//www.tuer.me" class=" wrap external" target="_blank" rel="nofollow noreferrer">兔耳日记 | 首页<i class="icon-external"></i></a><br>完全使用nodejs开发的后台。但是其他一些已经在线上的站点还有哪些？<br>我知道的还有cnodejs的社区也是nodejs编写的，还有雪球网貌似也是，还有阿里的数据产品团队也在使用nodejs。发布于 2013-07-109关注问题3 条评论感谢分享收藏•举报•作者保留权利更多分享收藏感谢举报•作者保留权利收起NodeJSNodeJS关注专栏•234 人关注•0 篇文章nodejs 应该学习哪些框架？80赞同80反对，不会显示你的姓名草依山web框架学一个 首推Koa， 次推 Express打包工具学一个 首推Webpack, 次推 rollup完整应用学一个 首推 cnodejs/nodeclub: Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统命令行工具一个 commander学学 ES6朴野归踪、鶸吉 等人赞同<ol><li>web框架学一个 首推Koa， 次推 Express</li><li>打包工具学一个 首推Webpack, 次推 rollup</li><li>完整应用学一个 首推 <a href="//link.zhihu.com/?target=https%3A//github.com/cnodejs/nodeclub" class=" wrap external" target="_blank" rel="nofollow noreferrer">cnodejs/nodeclub: Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统<i class="icon-external"></i></a></li><li>命令行工具一个 <a href="//link.zhihu.com/?target=https%3A//www.npmjs.com/package/commander" class=" wrap external" target="_blank" rel="nofollow noreferrer">commander<i class="icon-external"></i></a></li><li>学学 ES6</li></ol>发布于 2017-03-0180关注问题9 条评论感谢分享收藏•举报•申请转载更多分享收藏感谢举报•作者保留权利收起Nodejs爬虫实战关注专栏•36 人关注•0 篇文章2016该如何学习nodejs？318赞同318反对，不会显示你的姓名David天码营-实战开发技术学习平台-创始人绝对的良心课程：node | 天码营 这个课程基于NodeJS和Express框架，通过实例的项目案例，你可以学到开发一个成熟Web应用所需的所有关键知识和经验： 开发环境的建立与项目管理：Git, npm, Grunt JavaScript编程基础：基本语法、面向对象特性 前端开发技术：…显示全部Fake Wukong、朴野归踪 等人赞同绝对的良心课程：<a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node" class=" wrap external" target="_blank" rel="nofollow noreferrer">node | 天码营<i class="icon-external"></i></a><br><br><p>这个课程基于NodeJS和Express框架，通过实例的项目案例，你可以学到开发一个成熟Web应用所需的所有关键知识和经验：</p><ul><li>开发环境的建立与项目管理：Git, npm, Grunt</li><br><li>JavaScript编程基础：基本语法、面向对象特性</li></ul><ul><li>前端开发技术：HTML、CSS、Bootstrap和JavaScript基础</li><br><li>Express框架：URL路由、模板、表单、Session、拦截器等</li></ul><ul><li><p>数据访问：MongoDB</p></li><li><p>应用的测试和生产环境的部署</p></li></ul><br>包含以下内容：<br><br>第1课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/http" class=" wrap external" target="_blank" rel="nofollow noreferrer">HTTP 协议<i class="icon-external"></i></a><br>第2课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/html" class=" wrap external" target="_blank" rel="nofollow noreferrer">HTML<i class="icon-external"></i></a><br>第3课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/css" class=" wrap external" target="_blank" rel="nofollow noreferrer">CSS<i class="icon-external"></i></a><br>第4课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/bootstrap" class=" wrap external" target="_blank" rel="nofollow noreferrer">Bootstrap<i class="icon-external"></i></a><br>第5课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/javascript" class=" wrap external" target="_blank" rel="nofollow noreferrer">Javascript<i class="icon-external"></i></a><br>第6课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/client-side-js" class=" wrap external" target="_blank" rel="nofollow noreferrer">客户端脚本<i class="icon-external"></i></a><br>第7课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/npm" class=" wrap external" target="_blank" rel="nofollow noreferrer">Node.js依赖管理: npm<i class="icon-external"></i></a><br>第8课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/express-js" class=" wrap external" target="_blank" rel="nofollow noreferrer">Express.js<i class="icon-external"></i></a><br>第9课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/form-submit" class=" wrap external" target="_blank" rel="nofollow noreferrer">表单的提交<i class="icon-external"></i></a><br>第10课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/form-validate" class=" wrap external" target="_blank" rel="nofollow noreferrer">表单的验证<i class="icon-external"></i></a><br>第11课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/db" class=" wrap external" target="_blank" rel="nofollow noreferrer">数据库<i class="icon-external"></i></a><br>第12课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/session" class=" wrap external" target="_blank" rel="nofollow noreferrer">Session<i class="icon-external"></i></a><br>第13课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/smtp" class=" wrap external" target="_blank" rel="nofollow noreferrer">邮件服务<i class="icon-external"></i></a><br>第14课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/email-id" class=" wrap external" target="_blank" rel="nofollow noreferrer">邮箱身份绑定<i class="icon-external"></i></a><br>第15课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/web-form" class=" wrap external" target="_blank" rel="nofollow noreferrer">深入web表单<i class="icon-external"></i></a><br>第16课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/js-lib" class=" wrap external" target="_blank" rel="nofollow noreferrer">使用前端工具<i class="icon-external"></i></a><br>第17课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/hbs" class=" wrap external" target="_blank" rel="nofollow noreferrer">Handlebars<i class="icon-external"></i></a><br>第18课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/partial" class=" wrap external" target="_blank" rel="nofollow noreferrer">模板片段<i class="icon-external"></i></a><br>第19课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/populate" class=" wrap external" target="_blank" rel="nofollow noreferrer">模型关联<i class="icon-external"></i></a><br>第20课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/config" class=" wrap external" target="_blank" rel="nofollow noreferrer">配置管理<i class="icon-external"></i></a><br>第21课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/grunt" class=" wrap external" target="_blank" rel="nofollow noreferrer">Grunt 入门<i class="icon-external"></i></a><br>第22课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/auto-build" class=" wrap external" target="_blank" rel="nofollow noreferrer">自动构建<i class="icon-external"></i></a><br>第23课 <a href="//link.zhihu.com/?target=http%3A//course.tianmaying.com/node/lesson/whats-more" class=" wrap external" target="_blank" rel="nofollow noreferrer">还能做什么？<i class="icon-external"></i></a>发布于 2016-03-02318关注问题31 条评论感谢分享收藏•举报•作者保留权利更多分享收藏感谢举报•作者保留权利收起写后端 Python，nodejs和php哪个更好一些？13赞同13反对，不会显示你的姓名eechen不妥协，不逐流。随性而不失个性，有设计而不漏痕迹。繁华阅尽处，简约不简单。如果你需要后端渲染HTML,需要后端支持热部署,需要后端内置大量Web开发库函数,那就用PHP.因为Python和Node都不支持热部署,都需要手动或自动重启服务进程才能使代码更新生效,而且其语言自带的库函数并不如PHP丰富,而且Python和Node默认没有模板引擎的功能,PHP…显示全部Zerone、大脑艾瑞克 等人赞同<p>如果你需要后端渲染HTML,需要后端支持热部署,需要后端内置大量Web开发库函数,那就用PHP.因为Python和Node都不支持热部署,都需要手动或自动重启服务进程才能使代码更新生效,而且其语言自带的库函数并不如PHP丰富,而且Python和Node默认没有模板引擎的功能,PHP则天生就支持嵌入到HTML中的模板功能.就算你需要后端只写接口,PHP同样适用,区别在于PHP不再输出HTML而是输出JSON罢了,PHP中用内置的json_encode就能轻松把PHP数组(数据库查询结果)编码为JSON.</p><p>性能方面 Nginx+PHP7-FPM 的组合足够,PHP-FPM容器在底层用C实现了一套多进程架构,利用多核应对并发不是问题.而且PHP-FPM还有进程池机制,运维和开发人员可以把存在严重IO阻塞操作的脚本请求放到一个单独的动态进程池中处理,避免阻塞到其他进程池,也就是说,PHP-FPM能在脚本级别的粗粒度上分离IO阻塞.</p>编辑于 2017-03-3013关注问题70 条评论感谢分享收藏•举报•作者保留权利更多分享收藏感谢举报•作者保留权利收起NodeJS 工程师必备的 8 个工具101赞101王仕军，前端周刊主笔读完约需 4 分钟，速读需 1 分钟 NodeJS 自诞生以来，社区的发展速度超出了所有人的想象，现在甚至可以被用来做诸如智能硬件、人脸识别的很多事情。在各种软件工程工作流中实现自动化，比如 APP 打包、WEB 开发方面自然也少不了它。根据我个人的经验，NodeJS…显示全部裴勇帅、Patrick、再见已是初识 等人赞同<img src="https://pic1.zhimg.com/v2-54fbe45d78671325f1965c740cf2686c_b.png" data-rawwidth="730" data-rawheight="365" class="origin_image zh-lightbox-thumb" width="730" data-original="https://pic1.zhimg.com/v2-54fbe45d78671325f1965c740cf2686c_r.png"><blockquote><p>本文共 1689 字，读完约需 4 分钟，速读需 1 分钟</p></blockquote><p>NodeJS 自诞生以来，社区的发展速度超出了所有人的想象，现在甚至可以被用来做诸如智能硬件、人脸识别的很多事情。在各种软件工程工作流中实现自动化，比如 APP 打包、WEB 开发方面自然也少不了它。根据我个人的经验，NodeJS 是用来快速构建精巧的、模块化的、能让开发者更轻松的各种工具的最佳选择。</p><p>下面是我长期开发积累的，全局安装在开发机上，频繁使用并且能在开发工作流中带来事半功倍效果的 8 个命令行工具，推荐给大家，希望对大家有用。</p><h2>1. create-react-app：快速搭建 React 应用的原型</h2><p>安装方法：npm install -g create-react-app，<a href="http://link.zhihu.com/?target=https%3A//github.com/facebookincubator/create-react-app" class=" wrap external" target="_blank" rel="nofollow noreferrer">create-react-app<i class="icon-external"></i></a> 由 Facebook 出品，能够帮你快速的生成 React 应用的骨架，里面包括典型 React 应用的基础依赖，最佳实践，包括：开发环境的各种工具，能直接修改运行的测试文件、工具，帮你构建源代码以便发布到生产环境的脚本。</p><h2>2. standard：傻瓜式的 Javascript 语法检查工具</h2><p>安装方法：npm install -g standard，<a href="http://link.zhihu.com/?target=http%3A//standardjs.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">standard<i class="icon-external"></i></a> 是代码检查工具领域的新秀，代码检查存在的必要性这里不再赘述。在代码风格检查领域有几款优秀的工具，按出现的先后顺序为：jslint、jshint、eslint，而跟 standard 同时出现的还要很多其他的，他的特点是傻瓜式，零配置即可上手，目前在已经有不少开源项目使用了这种风格，无需任何配置，只需要用过命令行就可以确保所有的代码贡献者提交的代码是风格一致的。</p><h2>3. nodemon：自动重启 NodeJS 应用</h2><p>安装方法，npm install -g nodemon，<a href="http://link.zhihu.com/?target=https%3A//nodemon.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer">nodemon<i class="icon-external"></i></a> 是一款监听服务运行时所在的目录源代码变化并自动重启服务的工具，是项目快速迭代时的完美伴侣，因为 nodemon 能帮你把重复工作降到最低。理论上 nodemon 支持各种语言的服务重启，并且支持监听目录和文件的自定义配置。</p><h2>4. pm2：便捷管理 node 服务进程</h2><p>安装方法，npm install -g pm2，<a href="http://link.zhihu.com/?target=http%3A//pm2.keymetrics.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer">pm2<i class="icon-external"></i></a> 是一款非常强大的服务进程管理工具，尤其适合用在生产环境，人人车所有的线上 node 服务都是用他来管理，开箱即用的特性包括：进程监控、负载均衡、内存监控、日志管理、服务管理。并且有需要的同学可以开启他官方的 node 应用监控后台支持：<a href="http://link.zhihu.com/?target=https%3A//keymetrics.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer">keymetrics.io<i class="icon-external"></i></a></p><h2>5. localtunnel：把本机服务暴露到外网</h2><p>安装方法：npm install -g localtunnel，<a href="http://link.zhihu.com/?target=https%3A//github.com/localtunnel/localtunnel" class=" wrap external" target="_blank" rel="nofollow noreferrer">localtunnel<i class="icon-external"></i></a>能够让你快速的把本机的服务暴露到公网上，提供给其他人使用、测试，不需要任何域名、虚拟主机。典型的使用场景比如做前端开发的同学可以利用这个工具把开发环境的服务提供给 PM 或者 QA 验收使用。提供类似服务的还有 ngrok 及其国内克隆版 natapp，但是都是收费的。</p><h2>6. david：帮你找到已经过期的依赖包</h2><p>安装方法：npm install -g david，<a href="http://link.zhihu.com/?target=https%3A//www.npmjs.com/package/david" class=" wrap external" target="_blank" rel="nofollow noreferrer">david<i class="icon-external"></i></a> 不仅仅能够让你知道你的项目中哪些依赖包需要升级，还提供了快速升级包的机制。npm 内置的工具有 npm outdated，但是 david 较之更优。</p><h2>7. nvm：Node 版本管理器</h2><p>安装方法参见 <a href="http://link.zhihu.com/?target=https%3A//github.com/creationix/nvm" class=" wrap external" target="_blank" rel="nofollow noreferrer">nvm<i class="icon-external"></i></a>，该工具不是 NodeJS 编写。顾名思义，他能够帮你安装、管理、切换不同版本的 NodeJS 引擎，对于开源项目维护者来说尤其实用。比如：你的项目需要支持 NodeJS 的 Current Release（7.X），也要支持 LTS Release（6.X），在跑测试的时候，辅以简单的脚本就可以在多个不同版本上做自动化回归。</p><h2>8. yarn：比 npm 更好的包管理器</h2><p>安装方法：npm install -g yarn，<a href="http://link.zhihu.com/?target=https%3A//yarnpkg.com/en/" class=" wrap external" target="_blank" rel="nofollow noreferrer">yarn<i class="icon-external"></i></a> 是 Facebook 出品的改良版 NodeJS 包管理器，在性能上有非常大的改进，依赖管理方面也修复了 npm 被人诟病了很久的无法锁定依赖的问题，但是国内的同学使用可能偶尔会遇到服务不稳定的情况。</p><p>结语：学习编程就像是在修炼武功，武学中倡导内外兼修，上述这些工具可以说是外家功夫，只要上手去用，遇到问题多搜索，假以时日你的开发效率自然会精进。</p><h2>One More Thing</h2><p>想读到更多类似内容？请订阅本专栏或者扫描封面中的二维码，订阅微信号。</p>编辑于 2017-03-24101关注专栏15 条评论分享•举报更多分享举报收起黑科技进化了，nodejs和miniblink融合起来了，晋级为node-blink！387赞387龙泉寺扫地僧，首席浏览器架构吹牛师，全球最小chromium改造版内核miniblink作者miniblink实现了一个有意思的黑科技：nodejs和miniblink在代码层面融合起来了： （miniblink的项目解释见：知乎专栏 简单的说，就是个追究极简的浏览器内核，一切以小巧为要） 其实原理很简单，node用的不就是v8么，miniblink也是用的v8。有天我们突发奇想…显示全部心灵的王、Shizhi Tang、张宗成 等人赞同<img src="https://pic4.zhimg.com/v2-182ca7c2420f694feeba4528ce511fef_b.png" data-rawwidth="667" data-rawheight="314" class="origin_image zh-lightbox-thumb" width="667" data-original="https://pic4.zhimg.com/v2-182ca7c2420f694feeba4528ce511fef_r.png">在<a href="http://link.zhihu.com/?target=https%3A//github.com/zero-ui" class=" wrap external" target="_blank" rel="nofollow noreferrer">zero-ui (冉朋)<i class="icon-external"></i></a> 的大力开发下，miniblink实现了一个有意思的黑科技：nodejs和miniblink在代码层面融合起来了：<p><img src="http://pic4.zhimg.com/v2-b9b270c1d0ecca69cb279ef0a7ba1cb7_b.png" data-rawwidth="989" data-rawheight="536" class="origin_image zh-lightbox-thumb" width="989" data-original="http://pic4.zhimg.com/v2-b9b270c1d0ecca69cb279ef0a7ba1cb7_r.png">（miniblink的项目解释见：<a href="https://zhuanlan.zhihu.com/p/22611497" class="internal">知乎专栏</a>  简单的说，就是个追究极简的浏览器内核，一切以小巧为要）</p><p>其实原理很简单，node用的不就是v8么，miniblink也是用的v8。有天我们突发奇想，为什么不把nodejs的能力直接融合到miniblink里，而且共用一个v8引擎。</p><p>把nodejs和浏览器内核结合起来，市面上很多开源产品了。比如nw.js和electron。但这回情况有点不一样了。nwjs那种，只是在功能方面。现在miniblink庄严的决定和node进行更深层次的融合：直接在代码层面也共用一套v8引擎。这样一个node再带上浏览能力，整体size也就增加大约5M而已。也就是说，大约18m以内的size，你就可以拥有nodejs和miniblink的双重能力了！</p><img src="http://pic3.zhimg.com/v2-ffa706243d31e69e3c7662d1a9a95cee_b.jpg" data-rawwidth="842" data-rawheight="501" class="origin_image zh-lightbox-thumb" width="842" data-original="http://pic3.zhimg.com/v2-ffa706243d31e69e3c7662d1a9a95cee_r.jpg"><p><img src="http://pic1.zhimg.com/v2-5327409d3ae465185e1d95fa0d8b0c30_b.png" data-rawwidth="649" data-rawheight="200" class="origin_image zh-lightbox-thumb" width="649" data-original="http://pic1.zhimg.com/v2-5327409d3ae465185e1d95fa0d8b0c30_r.png"><img src="http://pic3.zhimg.com/v2-d0f6762d7afb6026a270e33fbced893a_b.png" data-rawwidth="1195" data-rawheight="550" class="origin_image zh-lightbox-thumb" width="1195" data-original="http://pic3.zhimg.com/v2-d0f6762d7afb6026a270e33fbced893a_r.png">下一步就是把electron导出给js的那堆js api也融合进来。想想electron和nodejs那几万个开源组件，可以直接让node-blink的开发者使用，而且带出去的安装包极小（大约8m），心里就激动( 嫌弃electron太大的朋友可以换个场子过来了)。以后，可以简称node-blink为NB，略显nb啊，哈哈哈哈。。。</p><br><p>项目地址：<a href="http://link.zhihu.com/?target=https%3A//github.com/weolar/miniblink49" class=" wrap external" target="_blank" rel="nofollow noreferrer">weolar/miniblink49<i class="icon-external"></i></a></p><p><b>demo正在整理中。想尝试的朋友现在得自己编译。虽然编译也简单，但建议等后续我们的demo整理完毕再说。</b></p><p>ps，这次使用的是NODE 6.x版本，然而里面的v8是最新版。</p>编辑于 2016-12-18387关注专栏59 条评论分享•举报更多分享举报收起[译] 阅读 NodeJS 文档，我学到了这 19 件事情129赞129Glowin，稀土(http://xitu.io)联合创始人，北京GDG 组织者。原文地址：19 things I learnt reading the NodeJS docs 原文作者：David Gilbertson 译文出自：掘金翻译计划 译者：jacksonke20120711@gmail.com 校对者：mortyu, rottenpen) 我相信我对 Node 了若指掌yipianzhuan、Black-Hole、dergum wong 等人赞同<img src="https://pic2.zhimg.com/v2-df15241ff65e77eb0c3f5659b7e2178d_b.jpg" data-rawwidth="1920" data-rawheight="1079" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://pic2.zhimg.com/v2-df15241ff65e77eb0c3f5659b7e2178d_r.jpg"><blockquote><ul><li>原文地址：<a href="http://link.zhihu.com/?target=https%3A//hackernoon.com/19-things-i-learnt-reading-the-nodejs-docs-8a2dcc7f307f%23.8iaiz8xls" class=" wrap external" target="_blank" rel="nofollow noreferrer">19 things I learnt reading the NodeJS docs<i class="icon-external"></i></a></li><li>原文作者：<a href="http://link.zhihu.com/?target=https%3A//hackernoon.com/%40david.gilbertson" class=" wrap external" target="_blank" rel="nofollow noreferrer">David Gilbertson<i class="icon-external"></i></a></li><li>译文出自：<a href="http://link.zhihu.com/?target=https%3A//github.com/xitu/gold-miner" class=" wrap external" target="_blank" rel="nofollow noreferrer">掘金翻译计划<i class="icon-external"></i></a></li><li>译者：jacksonke20120711@gmail.com</li><li>校对者：<a href="http://link.zhihu.com/?target=https%3A//github.com/mortyu" class=" wrap external" target="_blank" rel="nofollow noreferrer">mortyu<i class="icon-external"></i></a>, <a href="http://link.zhihu.com/?target=http%3A//rottenpen%2520%28%25E6%25BB%2591%25E5%25A8%2581" class=" wrap external" target="_blank" rel="nofollow noreferrer">rottenpen<i class="icon-external"></i></a>)</li></ul></blockquote><p>我相信我对 Node 了若指掌。我这 3 年来写的网站都是用 Node 来开发的。但实际上，我从没有详细查看 Node 文档。</p><p>长期的订阅者应该知道，我正处在书写每一个接口(interface)，属性(prop)，方法(method)，函数(function)，数据类型(data type)等等关于 Web 开发的漫漫长途中，这样可以填补我的知识面的空缺。在完成了 HTML，DOM, WebApi, CSS, SVG 和 EcmaScript 之后, Node 文档会是我的最后一站。</p><p>对我来说，这里面有很多宝贵的知识，所以我想简短地列举，并且分享它们。我会按吸引力从高到低列举它们，好比我见新朋友时的衣服顺序，（最吸引人的放外面 ^_^）</p><h3>把 querystring 当作通用解析器</h3><p>假设你从一些古怪的数据库中获取到的数据是一些键值对数组，格式像name:Sophie;shape:fox;condition:new。很自然的，你会将它当成一个 JavaScript 对象。你会将所取得的数据以;为分隔符切分成数组，然后遍历数组，用:分割，第一项作为属性，第二项作为该属性对应的值。</p><p>这样对吧？</p><p>不用这般麻烦的，你可以使用 querystring</p><div class="highlight"><pre><code class="language-text"><span></span>const weirdoString = `name:Sophie;shape:fox;condition:new`;
const result = querystring.parse(weirdoString, `;`, `:`);

// result:
// {
//   name: `Sophie`,
//   shape: `fox`,
//   condition: `new`,
// };
</code></pre></div><p><a href="http://link.zhihu.com/?target=http%3A//Node.js%2520v7.2.0%2520Documentation" class=" wrap external" target="_blank" rel="nofollow noreferrer">Query String | Node.js v7.0.0 Documentation_By default, percent-encoded characters within the query string will be assumed to use UTF-8 encoding. If an alternative…http://_nodejs.org<i class="icon-external"></i></a></p><h3>V8 Inspector</h3><p>运行 node，加上--inspect选项，会给出一个 URL 地址。粘贴该 URL 到 Chrome。哈哈，这就能用 Chrome DevTools 调试 Node，这多方便，多轻松。这篇文章有介绍如何使用<a href="http://link.zhihu.com/?target=https%3A//medium.com/%40paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27%23.evhku718w" class=" wrap external" target="_blank" rel="nofollow noreferrer"> how-to by Paul Irish over here <i class="icon-external"></i></a>.</p><p>虽然它现在还处于“试验”阶段，但是现在已经极大地解决了我的困挠。</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/debugger.html%23debugger_v8_inspector_integration_for_node_js" class=" wrap external" target="_blank" rel="nofollow noreferrer">Debugger | Node.js v7.0.0 Documentation_Node.js includes a full-featured out-of-process debugging utility accessible via a simple TCP-based protocol and built…http://_nodejs.org<i class="icon-external"></i></a></p><h3>nextTick 和 setImmediate 的不同点</h3><p>和多数情况一样，如果能给它们起个更贴切的名字，就很容易记住两者的不同了。</p><p>process.nextTick() 是 process.sendThisToTheStartOfTheQueue().(译者注：放入队列的第一个位置)</p><p>setImmediate() 应该被叫做 sendThisToTheEndOfTheQueue().(译者注：放入队列的尾部，最后一个处理的)</p><p>(题外话：React 中，我通常将props当成stuffThatShouldStayTheSameIfTheUserRefreshes，而将state当成stuffThatShouldBeForgottenIfTheUserRefreshes.这两者长度一致也是个意外，哈哈哈。)</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/timers.html%23timers_setimmediate_callback_args" class=" wrap external" target="_blank" rel="nofollow noreferrer">Node.js v7.0.0 Documentation_Stability: 3 — Locked The timer module exposes a global API for scheduling functions to be called at some future period…http://_nodejs.org<i class="icon-external"></i></a></p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/process.html%23process_process_nexttick_callback_args" class=" wrap external" target="_blank" rel="nofollow noreferrer">process | Node.js v7.0.0 Documentation_A process warning is similar to an error in that it describes exceptional conditions that are being brought to the user…http://_nodejs.org<i class="icon-external"></i></a></p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/en/blog/release/v0.10.0/%23faster-process-nexttick" class=" wrap external" target="_blank" rel="nofollow noreferrer">Node v0.10.0 (Stable)_I am pleased to announce a new stable version of Node. This branch brings significant improvements to many areas, with…http://_nodejs.org<i class="icon-external"></i></a></p><h3>Server.listen 只带一个参数对象</h3><p>对于参数传递，我倾向于只使用一个参数 options ，而不是传 5 个没命名且必须按照特定顺序的参数。这可以在服务端监听连接时使用。</p><div class="highlight"><pre><code class="language-text"><span></span>require(`http`)
  .createServer()
  .listen({
    port: 8080,
    host: `localhost`,
  })
  .on(`request`, (req, res) =&gt; {
    res.end(`Hello World!`);
  });
</code></pre></div><p>这个文档比较隐蔽，它并不在http.Server的方法列表里，而是在net.Server中（http.Server继承net.Server）</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/net.html%23net_net_createserver_options_connectionlistener" class=" wrap external" target="_blank" rel="nofollow noreferrer">net | Node.js v7.0.0 Documentation_Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the…http://_nodejs.org<i class="icon-external"></i></a></p><h3>相对路径</h3><p>传入fs模块方法的路径可以是相对路径。这是相对于process.cwd()。这可能多数人都知道了，但我以前一直以为要传入绝对路径。</p><div class="highlight"><pre><code class="language-text"><span></span>const fs = require(`fs`);
const path = require(`path`);

// why have I always done this...
fs.readFile(path.join(__dirname, `myFile.txt`), (err, data) =&gt; {
  // do something
});

// when I could just do this?
fs.readFile(`./path/to/myFile.txt`, (err, data) =&gt; {
  // do something
});
</code></pre></div><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/fs.html%23fs_file_system" class=" wrap external" target="_blank" rel="nofollow noreferrer">File System | Node.js v7.0.0 Documentation_birthtime “Birth Time” — Time of file creation. Set once when the file is created. On filesystems where birthtime is…http://_nodejs.org<i class="icon-external"></i></a></p><h3>路径解析</h3><p>以前我会显摆的技术之一就是使用正则表达式从路径字符串中获取文件名和拓展名，这其实根本没有必要，需要做的仅仅是调用接口：</p><div class="highlight"><pre><code class="language-text"><span></span>myFilePath = `/someDir/someFile.json`;
path.parse(myFilePath).base === `someFile.json`; // true
path.parse(myFilePath).name === `someFile`; // true
path.parse(myFilePath).ext === `.json`; // true
</code></pre></div><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/path.html%23path_path_parse_path" class=" wrap external" target="_blank" rel="nofollow noreferrer">Node.js v7.0.0 Documentation_Stability: 2 — Stable The path module provides utilities for working with file and directory paths. It can be accessed…http://_nodejs.org<i class="icon-external"></i></a></p><h3>使用不同颜色来记录日志</h3><p>使用console.dir(obj, {colors: true})可以使用预先设置好的配色方案打印日志，这样更易于阅读。</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/console.html%23console_console_dir_obj_options" class=" wrap external" target="_blank" rel="nofollow noreferrer">Console | Node.js v7.0.0 Documentation_The console functions are usually asynchronous unless the destination is a file. Disks are fast and operating systems…http://_nodejs.org<i class="icon-external"></i></a></p><h3>让 setInterval() 不去影响应用的效率</h3><p>假设你使用setInterval()来执行数据库清理操作，一天一次。默认情况下，只要setInterval()的请求还在， Node  的事件循环是不会停止的。如果你想让 Node 休息（我也不知道这样做的好处），你可以这么做：</p><div class="highlight"><pre><code class="language-text"><span></span>const dailyCleanup = setInterval(() =&gt; {
  cleanup();
}, 1000 * 60 * 60 * 24);

dailyCleanup.unref();
</code></pre></div><p>需要注意的是，如果你的队列中没有其它的请求（比如 http 服务监听），Node 会退出的。</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/timers.html%23timers_timeout_unref" class=" wrap external" target="_blank" rel="nofollow noreferrer">Node.js v7.0.0 Documentation_Stability: 3 — Locked The timer module exposes a global API for scheduling functions to be called at some future period…http://_nodejs.org<i class="icon-external"></i></a></p><h3>使用 Signal 常量</h3><p>可能你以前会这样处理 kill：</p><div class="highlight"><pre><code class="language-text"><span></span>process.kill(process.pid, `SIGTERM`);
</code></pre></div><p>如果计算机编程的历史不存在由错字引发的错误，这样做没什么错的。但是实际上这是发生过的。第二个参数可以是带上’string’<strong>或者</strong>对应的 int ，你可以使用下面更健壮的方式</p><div class="highlight"><pre><code class="language-text"><span></span>process.kill(process.pid, os.constants.signals.SIGTERM);
</code></pre></div><h3>IP 地址有效性验证</h3><p>Node 已经有内置的 IP 地址校验器。我以前不止一次自己写正则表达式去做这个。好蠢（┬＿┬）</p><p>require(net).isIP(10.0.0.1) will return 4.</p><p>require(net).isIP(cats) will return 0.</p><p>因为cats并不是一个IP地址</p><p>如果你没注意到，我正经历着这么个阶段，字符串使用反引号包起来， 它在我身上越来越多，但我知道它看起来很奇怪，所以我特意提到它。。。（作者的唠叨）</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/net.html%23net_net_isip_input" class=" wrap external" target="_blank" rel="nofollow noreferrer">net | Node.js v7.0.0 Documentation_Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the…http://_nodejs.org<i class="icon-external"></i></a></p><h3>os.EOL</h3><p>你曾经对行结束符硬编码吗？</p><p>我的天！</p><p>os.EOL是专门为你准备的，它在 Windows 操作系统上为\r\n，在其它系统上是\n。<a href="http://link.zhihu.com/?target=https%3A//github.com/sasstools/sass-lint/pull/92/files" class=" wrap external" target="_blank" rel="nofollow noreferrer">使用 os.EOL <i class="icon-external"></i></a> 能让你的代码在不同的操作系统上表现一致。</p><div class="highlight"><pre><code class="language-text"><span></span>const fs = require(`fs`);

// bad
fs.readFile(`./myFile.txt`, `utf8`, (err, data) =&gt; {
  data.split(`\r\n`).forEach(line =&gt; {
    // do something
  });
});

// good
const os = require(`os`);
fs.readFile(`./myFile.txt`, `utf8`, (err, data) =&gt; {
  data.split(os.EOL).forEach(line =&gt; {
    // do something
  });
});
</code></pre></div><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/os.html%23os_os_eol" class=" wrap external" target="_blank" rel="nofollow noreferrer">OS | Node.js v7.0.0 Documentation_{ model: ‘Intel(R) Core(TM) i7 CPU 860 @ 2.80GHz’, speed: 2926, times: { user: 252020, nice: 0, sys: 30340, idle…http://_nodejs.org<i class="icon-external"></i></a></p><h3>状态码查询</h3><p>HTTP 状态码及其对应的易读性的名字是可以查询的。http.STATUS_CODES正是我这里想说的，它的键是个状态码，值对应其状态的简短描述。<img src="http://pic2.zhimg.com/v2-af85b395794584ce40ebb89b8ce7f101_b.png" data-rawwidth="324" data-rawheight="371" class="content_image" width="324"></p><p>所以你可以这么做：</p><div class="highlight"><pre><code class="language-text"><span></span>someResponse.code === 301; // true
require(`http`).STATUS_CODES[someResponse.code] === `Moved Permanently`; // true
</code></pre></div><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/http.html%23http_http_status_codes" class=" wrap external" target="_blank" rel="nofollow noreferrer">HTTP | Node.js v7.0.0 Documentation_The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally…http://_nodejs.org<i class="icon-external"></i></a></p><h3>预防崩溃</h3><p>我一直认为下面的这种错误导致的服务崩溃是非常荒谬的：</p><div class="highlight"><pre><code class="language-text"><span></span>const jsonData = getDataFromSomeApi(); // But oh no, bad data!
const data = JSON.parse(jsonData); // Loud crashing noise.
</code></pre></div><p>预防这种可笑的错误，你可以在你 app 的中使用process.on(uncaughtException, console.error);</p><p>当然，我不是傻瓜，在付费的项目中，我会使用<a href="http://link.zhihu.com/?target=http%3A//pm2.keymetrics.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer"> PM2 <i class="icon-external"></i></a>，同时把所有的东西都装到try...catch语句中。但是，私人免费项目就另说 o_o ….</p><p>警告，这个<a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/process.html%23process_warning_using_uncaughtexception_correctly" class=" wrap external" target="_blank" rel="nofollow noreferrer">并非最好的练习<i class="icon-external"></i></a>,在大点复杂点的 app  中，这甚至可能是个坏主意。这需要你来决定是否要信任一个家伙的博客文章或官方文档。</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/process.html%23process_event_uncaughtexception" class=" wrap external" target="_blank" rel="nofollow noreferrer">process | Node.js v7.0.0 Documentation_A process warning is similar to an error in that it describes exceptional conditions that are being brought to the user…http://_nodejs.org<i class="icon-external"></i></a></p><h3>Just this once()</h3><p>对所有的事件发送者(EventEmitters)，除了on()方法之外，还有once()，我很确认我是地球上最后一个学到这点的人 (T_T) </p><div class="highlight"><pre><code class="language-text"><span></span>server.once(`request`, (req, res) =&gt; res.end(`No more from me.`));
</code></pre></div><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/events.html%23events_emitter_once_eventname_listener" class=" wrap external" target="_blank" rel="nofollow noreferrer">Events | Node.js v7.0.0 Documentation_Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds…http://_nodejs.org<i class="icon-external"></i></a></p><h3>定制控制台</h3><p>你可以使用 new console.Console(standardOut, errorOut) 创建你自己的控制台，传入你自己的输出流。</p><p>为什么要定制控制台? 我也不知道。或许想要将一些内容输出到文件，套接字，或者其他东西的时候，会考虑定制控制台。</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/console.html%23console_new_console_stdout_stderr" class=" wrap external" target="_blank" rel="nofollow noreferrer">Console | Node.js v7.0.0 Documentation_The console functions are usually asynchronous unless the destination is a file. Disks are fast and operating systems…http://_nodejs.org<i class="icon-external"></i></a></p><h3>DNS查询结果</h3><p>Node <a href="http://link.zhihu.com/?target=https%3A//github.com/nodejs/node/issues/5893" class=" wrap external" target="_blank" rel="nofollow noreferrer">不缓存 DNS 返回的结果<i class="icon-external"></i></a>.所以当你一次又一次地查询同一个 URL 的时候，其实已经浪费了很多宝贵的时间。这种情况下，你完全可以自己调用dns.lookup()并缓存结果的。或者可以<a href="http://link.zhihu.com/?target=https%3A//www.npmjs.com/package/dnscache" class=" wrap external" target="_blank" rel="nofollow noreferrer">这么<i class="icon-external"></i></a>做，这个是先前有人实现的。</p><div class="highlight"><pre><code class="language-text"><span></span>dns.lookup(`http://www.myApi.com`, 4, (err, address) =&gt; {
  cacheThisForLater(address);
});
</code></pre></div><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/dns.html%23dns_dns_lookup_hostname_options_callback" class=" wrap external" target="_blank" rel="nofollow noreferrer">DNS | Node.js v7.0.0 Documentation_2) Functions that connect to an actual DNS server to perform name resolution, and that always use the network to…http://_nodejs.org<i class="icon-external"></i></a></p><h3>fs模块是多操作系统兼容性的雷区</h3><p>如果你写代码的风格和我一样—阅读最少的知识，微调程序，直到它可以运行。那么，你很有可能也会触到fs模块的雷区。虽然 Node 为多操作系统的兼容性做了很多，但毕竟也只能做到那么多。许多 OS 的不同特性就像代码海洋中突起的珊瑚瞧，每个瞧石都隐藏着风险。而你，仅仅是小船。</p><p>不幸的是，这些不同点不仅仅是存在于 Windows 和其它操作系统之间，所以，你不能简单的自我安慰“哇，太好了，没人使用  Windows”。（我写过一大篇反对使用 Windows 来进行 Web 开发的文章，但我自己把它删了，因为那些说教，连我自己看了都翻白眼）。</p><p>下面这些是你在使用fs模块时，可能碰到的坑</p><ul><li>fs.stats()返回的mode属性在 Windows 和其它操作系统上是不同的（在 Windows 上没有匹配一些文件模式常量，比如 fs.constants.S_IRWXU）</li><li>fs.lchmod()只能在 macOS 中使用</li><li>fs.symlink() 的type参数只可能在 Windows 上使用</li><li>fs.watch() 选项recursive只能在 macOS 和 Windows 中使用。</li><li>fs.watch() 在 Windows 和 Linux 上，回调只会接受一个文件名</li><li>fs.open() 打开一个文件夹，在 FreeBSD 和 Windows 上使用a+属性是可以的，但是在 macOS 和 Linux 上是不行的。</li><li>fs.write() 在linux上，当文件是以append的方式打开的，参数position是会被直接忽视掉的，直接在文件末尾添加。</li></ul><p>(我还算挺赶时髦的，我已经改用macOS了，OS X只用了 49 天)</p><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/fs.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">File System | Node.js v7.0.0 Documentation_birthtime “Birth Time” – Time of file creation. Set once when the file is created. On filesystems where birthtime is…http://_nodejs.org<i class="icon-external"></i></a></p><h3>net 模块是 http 模块速度的两倍</h3><p>阅读文档，我学到了net模块是个事儿。它支撑着http模块。这会让我思索，假如我只想做服务器间的通讯 (server-to-server communication )，我是不是只需要使用net模块？</p><p>网上的人或许很难相信我不能凭直觉获得答案。作为一个 Web 开发者，我一开始就扎进了服务端的世界里，我知道 http 但是其他方面并不是很多。所有的  TCP, 套接字，流之类的对我来说就像<a href="http://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DFQgH4G3qypI" class=" wrap external" target="_blank" rel="nofollow noreferrer">日本摇滚<i class="icon-external"></i></a>.我真的不是很明白，但是我很好奇。</p><p>为了比较验证我的想法，我建立了多个服务端程序，（我相信这时你肯定在听日本摇滚了）,并且发送了多个请求。结论是 http.Server每秒中处理了大约3,400个请求，net.Server每秒钟处理5,500个。</p><p>它其实也很简单。</p><p>如果你感兴趣的话，可以查看我的代码。如果不感兴趣，那不好意思，需要你滚动页面了。</p><div class="highlight"><pre><code class="language-text"><span></span>// This makes two connections, one to a tcp server, one to an http server (both in server.js)
// It fires off a bunch of connections and times the response

// Both send strings.

const net = require(`net`);
const http = require(`http`);

function parseIncomingMessage(res) {
  return new Promise((resolve) =&gt; {
    let data = ``;

    res.on(`data`, (chunk) =&gt; {
      data += chunk;
    });

    res.on(`end`, () =&gt; resolve(data));
  });
}

const testLimit = 5000;

/*  ------------------  */
/*  --  NET client  --  */
/*  ------------------  */
function testNetClient() {
  const netTest = {
    startTime: process.hrtime(),
    responseCount: 0,
    testCount: 0,
    payloadData: {
      type: `millipede`,
      feet: 100,
      test: 0,
    },
  };

  function handleSocketConnect() {
    netTest.payloadData.test++;
    netTest.payloadData.feet++;

    const payload = JSON.stringify(netTest.payloadData);

    this.end(payload, `utf8`);
  }

  function handleSocketData() {
    netTest.responseCount++;

    if (netTest.responseCount === testLimit) {
      const hrDiff = process.hrtime(netTest.startTime);
      const elapsedTime = hrDiff[0] * 1e3 + hrDiff[1] / 1e6;
      const requestsPerSecond = (testLimit / (elapsedTime / 1000)).toLocaleString();

      console.info(`net.Server handled an average of ${requestsPerSecond} requests per second.`);
    }
  }

  while (netTest.testCount  {
      httpTest.responseCount++;

      if (httpTest.responseCount === testLimit) {
        const hrDiff = process.hrtime(httpTest.startTime);
        const elapsedTime = hrDiff[0] * 1e3 + hrDiff[1] / 1e6;
        const requestsPerSecond = (testLimit / (elapsedTime / 1000)).toLocaleString();

        console.info(`http.Server handled an average of ${requestsPerSecond} requests per second.`);
      }
    });
  }

  while (httpTest.testCount  {
  console.info(`Starting testNetClient()`);
  testNetClient();
}, 50);

setTimeout(() =&gt; {
  console.info(`Starting testHttpClient()`);
  testHttpClient();
}, 2000);

// This sets up two servers. A TCP and an HTTP one.
// For each response, it parses the received string as JSON, converts that object and returns a string
const net = require(`net`);
const http = require(`http`);

function renderAnimalString(jsonString) {
  const data = JSON.parse(jsonString);
  return `${data.test}: your are a ${data.type} and you have ${data.feet} feet.`;
}

/*  ------------------  */
/*  --  NET server  --  */
/*  ------------------  */

net
  .createServer((socket) =&gt; {
    socket.on(`data`, (jsonString) =&gt; {
      socket.end(renderAnimalString(jsonString));
    });
  })
  .listen(8888);

/*  -------------------  */
/*  --  HTTP server  --  */
/*  -------------------  */

function parseIncomingMessage(res) {
  return new Promise((resolve) =&gt; {
    let data = ``;

    res.on(`data`, (chunk) =&gt; {
      data += chunk;
    });

    res.on(`end`, () =&gt; resolve(data));
  });
}

http
  .createServer()
  .listen(8080)
  .on(`request`, (req, res) =&gt; {
    parseIncomingMessage(req).then((jsonString) =&gt; {
      res.end(renderAnimalString(jsonString));
    });
  });
</code></pre></div><p><a href="http://link.zhihu.com/?target=https%3A//nodejs.org/api/net.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">net | Node.js v7.0.0 Documentation_Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the…http://_nodejs.org<i class="icon-external"></i></a></p><h3>REPL技巧</h3><ol><li>当你处于 REPL（那是你在控制台敲入node，并按了回车键的情形），你可以敲入.load someFile.js，这时，它会将这个文件的内容加载进来。（比如，你可以加载一个包含大量常量的文件）。</li><li>当你设置环境变量NODE_REPL_HISTORY=""，这样可以禁止 repl 的历史写入文件中。同时我也学到（至少是被提醒了）REPL 的历史默认是写到~/.node_repl_history中，当你想回忆起之前的 REPL 历史时，可以上这儿查。</li><li>_ 这个变量，保存着上一次的计算结果. 相当方便!</li><li>当你进入 REPL 模式中时，模块都已经为你加载好了。所以了，比如说，你可以直接敲入os.arch()查看操作系统体系结构。你不需要先敲入require(os).arch(); (注: 确的说，是按需加载的模块.)</li></ol><p>插播一条广告：12 月 17 日，由 W3C 主办的中国第三届 CSS 开发者大会在天虹锦都酒店举办。此次大会，将邀请行业内知名讲师，与大家共聚广州，畅聊 CSS。大会邀请的嘉宾来自阿里、微信、Adobe Typekit 的资深前端工程师，来和 Mathias Bynens、Wenting Zhang、大漠、陈剑鑫、勾三股四等一起探讨 CSS 那些事。感兴趣的小伙伴快来<a href="http://link.zhihu.com/?target=https%3A//css.w3ctech.com/%3Futm_source%3Djuejin" class=" wrap external" target="_blank" rel="nofollow noreferrer">报名<i class="icon-external"></i></a>参加吧！</p><br>编辑于 2016-12-07129关注专栏8 条评论分享•举报更多分享举报收起怎么才能成为一个nodejs大神？11赞同11反对，不会显示你的姓名dboyitlr.cc下面这些是必要的http 协议一个sql或nosql数据库的使用js回调管理能力node的核心概念，EventEmitter，Stream一个node框架，精通middleware这个模式（并不复杂）精通node程序调试技巧，工具张世杰、柏舟 等人赞同<p>下面这些是必要的</p><ol><li>http 协议</li><li>一个sql或nosql数据库的使用</li><li>js回调管理能力</li><li>node的核心概念，EventEmitter，Stream</li><li>一个node框架，精通middleware这个模式（并不复杂）</li><li>精通node程序调试技巧，工具</li></ol>编辑于 2017-06-0211关注问题3 条评论感谢分享收藏•举报•申请转载更多分享收藏感谢举报•作者保留权利收起搜索技术由提供{}["","","","-1","",0,0]
{"realname_win_config":{"timestamp":1501344000,"tip":"\u5e94\u56fd\u5bb6\u6cd5\u89c4\u5bf9\u4e8e\u5e10\u53f7\u5b9e\u540d\u7684\u8981\u6c42\uff0c\u8fdb\u884c\u4e0b\u4e00\u6b65\u64cd\u4f5c\u524d\uff0c\u9700\u8981\u5148\u5b8c\u6210\u624b\u673a\u7ed1\u5b9a\u3002","continue":0,"continue_time":3600,"skip_ut_verification":1}}
[null,null,false]
["zhihu.com","comet.zhihu.com",false,null,false,false]
[]


{"user_created":0,"now":1504248737000,"abtest_mask":"------------------------------","user_attr":[0,0,0,"-","-"],"user_hash":0}

{"Copyright":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/Copyright.e82ba7e1.js","PayUIApp":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/PayUIApp.ca78ba78.js","CouponApp":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/CouponApp.5410e48b.js","PaymentApp":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/PaymentApp.7f16d61c.js","Community":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/Community.76812bc0.js","Report":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/Report.1a8d7f59.js","OrgOpHelp":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/OrgOpHelp.96defc04.js","common":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/common.a4dd3236.js","BalanceApp":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/BalanceApp.fb722aef.js","AnswerWarrant":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/AnswerWarrant.343d4d99.js","CommentApp":"https:\/\/static.zhihu.com\/static\/revved\/-\/apps\/CommentApp.3e80bc0c.js"}刘看山知乎指南建议反馈移动应用加入知乎知乎协议联系我们© 2017 知乎"nodejs"





